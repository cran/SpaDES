<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>\newpage</p>

<h1>Introduction</h1>

<h2>Module overview</h2>

<p>Recall that <code>SpaDES</code> simulations are event-driven, meaning that different actions are performed on data objects based on the order of scheduled events.
The central design of <code>SpaDES</code> promotes modularity, such that collections of related simulation actions can be grouped together as &#39;modules&#39; and easily reused among multiple simulations.
Strict modularity requires that modules can act independently, without needing to know about other modules.
Thus each <code>SpaDES</code> module must explicitly state its input dependencies (data, package, and parameterization requirements), data outputs, as well as provide other useful metadata and documentation for the user.
Upon initialization of a simulation via <code>simInit</code>, the dependencies of every module used are examined and evaluated.
If dependency incompatibilities exists, the initialization fails and the user is notified.
Also during this initialization, module code is <code>source</code>-ed into the simulation environment, making all module objects and functions available during the simulation.</p>

<p>Each <code>SpaDES</code> module describes the processes or activities that drive simulation state changes via changes to objects stored in the simluation environment.
Each activity consists of a collection of events which are scheduled depending on the rules of the simulation.
Each event may evaluate or modify a simulation data object (<em>e.g.</em>, update the values on a raster map), or perform other operations such as saving and loading data objects, plotting, or scheduling other events.</p>

<h3>Simulation event list</h3>

<p>The event queue is stored in a slot in a <code>simList</code> simulation object.
Each event is represented by a <code>data.table</code> row consisting of the time the event is to occur (<code>eventTime</code>), the name of the module from which the event is taken (<code>moduleName</code>), and a character string for the programmer-defined event type (<code>eventType</code>).
This list is kept sorted by <code>eventTime</code>, and events are processed in sequence beginning at the top of the list.
Completed events are removed from the queue.</p>

<h3>Module events</h3>

<p>When a call to the event list is made, the event is processed by the module specified by <code>moduleName</code>.
The module code then determines the event type and executes the code for that event.
For each event type within a module: 1) the instructions for what happens for this event get executed; and 2) there is an optional call to <code>scheduleEvent</code>, which schedules a future event.
A module can schedule other event types from within the same module, and should not call other modules because this introduces module dependencies, which breaks the drop-in/replace modularity of your simulation model.</p>

<h3>Module event dependencies</h3>

<p>Each module schedules its own events (<em>e.g.</em>, a &#39;fire&#39; module may schedule &#39;burn&#39; events) and only uses its own data objects (or shared simulation objects).
Modules that behave in this way are independent of one another, which is the preferred way to design and implement modules.
Maintaining strict modularity allows the removal, additon, and replacement of modules without having to rewrite your code.</p>

<p>Module event dependencies complicate the construction of simulation models, and hinder the ability to develop and deploy models with modularity.
If two modules are actually depedent on each others&#39; events, then you should consider whether they really are separate modules or should be merged into a single module.</p>

<p>\newpage</p>

<h1>Module structure</h1>

<h2>Module directory structure (<code>moduleName/</code>)</h2>

<p>A module consists of a collection of files that &hellip;</p>

<pre><code>/moduleRepository
  |_ moduleName/
      |_ moduleName.R           # the actual module code file, incl. module metadata
      |_ moduleName.Rmd         # longform documentation and usage info, etc.
      |_ citation.bib           # properly formatted bibtex citation for the module
      |_ LICENSE.txt            # license file describing the allowed usage etc. of the module
      |_ README.txt             # incl. module metadata in addition to version change info, etc.
      |_ moduleName_x.y.z.zip   # zip archive of previous module versions
</code></pre>

<h2>Module code file (<code>moduleName.R</code>)</h2>

<p>A <code>SpaDES</code> module consists of a single <code>.R</code> source file, whose name matches the name of the module.
This file consists of three parts containing the code for:</p>

<ol>
<li>the metadata describing the module and its data dependencies;</li>
<li>defining the event types described in the module;</li>
<li>functions describing what happens during the processing of each event type.</li>
</ol>

<h3>Metadata</h3>

<p>In order to interact correctly with one another in a simulation, <code>SpaDES</code> modules are designed to be aware of their own dependencies and to share this information with the simulation (and to the user).
During simulation initialization, the <code>.R</code> file corresponding to each module used is parsed and the modules&#39; metadata stored in the <code>simList</code> object inside the <code>envir</code>.
As part of this initialization step, the dependencies of each module are extracted from the metadata and are checked against the other modules used in the simulation to ensure that all dependencies can be resolved.</p>

<h4>Defining module metadata: <code>defineModule()</code></h4>

<p>Every module requires complete metadata, structured as a named list, and passed as an argument to the <code>defineModule</code> function.</p>

<table><thead>
<tr>
<th><strong>Element name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td><strong><code>name</code></strong></td>
<td>Name of the module as a character string.</td>
</tr>
<tr>
<td><strong><code>description</code></strong></td>
<td>Description of the module as a character string.</td>
</tr>
<tr>
<td><strong><code>keywords</code></strong></td>
<td>Character vector containing a module&#39;s keywords.</td>
</tr>
<tr>
<td><strong><code>childModules</code></strong></td>
<td>Character vector containing the names of the child modules that are part of this module.</td>
</tr>
<tr>
<td><strong><code>authors</code></strong></td>
<td>The author(s) of the module as a <code>person</code> object.</td>
</tr>
<tr>
<td><strong><code>version</code></strong></td>
<td>The module version as a <code>numeric_version</code>. <a href="http://semver.org/">Semantic versioning</a> is assumed.</td>
</tr>
<tr>
<td><strong><code>spatialExtent</code></strong></td>
<td>Specifies the module&#39;s spatial extent as an <code>Extent</code> object.</td>
</tr>
<tr>
<td><strong><code>timeframe</code></strong></td>
<td>Specifies the valid timeframe for which the module was designed to simulate.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>Must be a <code>POSIXt</code> object of length <code>2</code>, specifying the start and end times.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>(NOT YET FULLY IMPLEMENTED.)</td>
</tr>
<tr>
<td><strong><code>timeunit</code></strong></td>
<td>Describes the unit of time corresponding to <code>1.0</code> simulation time units.</td>
</tr>
<tr>
<td><strong><code>citation</code></strong></td>
<td>A citation for the module, as a character string.</td>
</tr>
<tr>
<td><strong><code>reqdPkgs</code></strong></td>
<td>Character vector of R package names to be loaded.</td>
</tr>
<tr>
<td><strong><code>parameters</code></strong></td>
<td>A <code>data.frame</code> constructed using <code>rbind</code> with <code>defineParameter</code>, specifying module</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>parameters, with columns <code>paramName</code>, <code>paramClass</code>, <code>default</code>, <code>min</code>, <code>max</code>, and <code>paramDesc</code>.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>Default values may be overridden by the user by passing a list of parameters to <code>simInit</code>.</td>
</tr>
<tr>
<td><strong><code>inputObjects</code></strong></td>
<td>A <code>data.frame</code> specifying the object dependencies of the module, with columns</td>
</tr>
<tr>
<td>&nbsp;</td>
<td><code>objectName</code>, <code>objectClass</code>, and <code>other</code>. For objects that are used within the module</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>as both an input and an output, add the object to each of these <code>data.frame</code>s.</td>
</tr>
<tr>
<td><strong><code>outputObjects</code></strong></td>
<td>A <code>data.frame</code> specifying the objects output by the module, following the format of</td>
</tr>
<tr>
<td>&nbsp;</td>
<td><code>inputObjects</code>.</td>
</tr>
</tbody></table>

<pre><code class="r">## sample module metadata for the default `randomLandscapes` module
## NOTE: long lines have been truncated
defineModule(sim, list(
  name=&quot;randomLandscapes&quot;,
  description=&quot;Generate RasterStack of random maps representative of a forest landsc...&quot;,
  keywords=c(&quot;random map&quot;, &quot;random landscape&quot;),
  authors=c(person(c(&quot;Alex&quot;, &quot;M&quot;), &quot;Chubaty&quot;, email=&quot;Alexander.Chubaty@NRCan.gc.ca&quot;,
                   role=c(&quot;aut&quot;, &quot;cre&quot;)),
            person(c(&quot;Eliot&quot;, &quot;J&quot;, &quot;B&quot;), &quot;McIntire&quot;, email=&quot;Eliot.McIntire@NRCan.gc.ca&quot;,
                   role=c(&quot;aut&quot;, &quot;cre&quot;))),
  version=numeric_version(&quot;0.2.0&quot;),
  spatialExtent=raster::extent(rep(NA_real_, 4)),
  timeframe=as.POSIXlt(c(NA, NA)),
  timeunit=NA_real_,
  citation=list(),
  reqdPkgs=list(&quot;raster&quot;, &quot;RColorBrewer&quot;, &quot;tkrplot&quot;, &quot;RandomFields&quot;),
  parameters=rbind(
    defineParameter(&quot;stackName&quot;, &quot;character&quot;, &quot;randomLandscape&quot;, NA, NA, &quot;...&quot;),
    defineParameter(&quot;nx&quot;, &quot;numeric&quot;, 100L, NA, NA, &quot;size of map (number ...&quot;),
    defineParameter(&quot;ny&quot;, &quot;numeric&quot;, 100L, NA, NA, &quot;size of map (number ...&quot;),
    defineParameter(&quot;inRAM&quot;, &quot;logical&quot;, FALSE, NA, NA, &quot;should the raster ...&quot;),
    defineParameter(&quot;.plotInitialTime&quot;, &quot;numeric&quot;, 0, NA, NA, &quot;time to ...&quot;),
    defineParameter(&quot;.plotInterval&quot;, &quot;numeric&quot;, 1, NA, NA, &quot;time interval ...&quot;),
    defineParameter(&quot;.saveInitialTime&quot;, &quot;numeric&quot;, NA_real_, NA, NA, &quot;time ...&quot;),
    defineParameter(&quot;.saveInterval&quot;, &quot;numeric&quot;, NA_real_, NA, NA, &quot;time ...&quot;)),
  inputObjects=data.frame(objectName=character(),
                          objectClass=character(),
                          other=character(), stringsAsFactors=FALSE),
  outputObjects=data.frame(objectName=globals(sim)$stackName,
                           objectClass=&quot;RasterStack&quot;,
                           other=NA_character_, stringsAsFactors=FALSE)
))
</code></pre>

<h4>Defining module parameters: <code>defineParameter()</code></h4>

<p>Parameters here differ from input data objects in that the former are intended to be variable across simulation runs, whereas the latter remain constant.
Parameters are often module-specific, where they are only used within the module they are defined, although it may be useful to globally define some parameters that are intended to be used by multiple modules.
Module-specific parameters are specified using <code>defineParameter</code> (with <code>rbind</code>) within <code>defineModule</code> to build a <code>data.frame</code> of input parameters.
Global parameters are defined at the simulation level as part of the <code>simInit</code> call.</p>

<p>The parameter list in the <code>simList</code> object (accessed via <code>params</code>) may be used to pass named parameter values to modules.
The general structure of this parameter list is <code>parameters$moduleName$moduleParameter</code>.
This nested list structure allows passing as many parameters as needed for your simulation.
We suggest passing a list of all the parameters needed for a single module together.</p>

<p>A module&#39;s metadata defines default values for module-specific parameters, and these defaults will be used unless overridden by the user.
Default parameter values can overridden by passing values in the parameter list to <code>simInit</code>.</p>

<pre><code class="r">require(SpaDES)

outputDir &lt;- file.path(tempdir(), &quot;simOutputs&quot;)
times &lt;- list(start=0.0, end=20.0)
parameters &lt;- list(.globals=list(stackName=&quot;landscape&quot;, burnStats=&quot;nPixelsBurned&quot;),
                   .progress=list(NA),
                   randomLandscapes=list(nx=100L, ny=100L, inRAM=TRUE),
                   fireSpread=list(nFires=10L, spreadprob=0.225, its=1e6,
                                   persistprob=0, returnInterval=10, startTime=0,
                                  .plotInitialTime=0.1, .plotInterval=10),
                   caribouMovement=list(N=100L, moveInterval=1, torus=TRUE,
                                        .plotInitialTime=1.01, .plotInterval=1))
modules &lt;- list(&quot;randomLandscapes&quot;, &quot;fireSpread&quot;, &quot;caribouMovement&quot;)
objects &lt;- list()
paths &lt;- list(modulePath=system.file(&quot;sampleModules&quot;, package=&quot;SpaDES&quot;),
              outputPath=outputDir)

mySim &lt;- simInit(times=times, params=parameters, modules=modules,
                 objects=objects, paths=paths)
</code></pre>

<h3>Event types</h3>

<p>Each module may contain an arbitrary number of event types.
Each of these event types are defined within the <code>doEvent.moduleName</code> call, and are wrapped in a simple <code>if</code>/<code>else</code> stanza that matches the called event type (NOTE: when several event types are defined, <code>switch</code>/case can faster than <code>if</code>/<code>else</code>).
To keep the <code>doEvent.moduleName</code> code block as clear and readable as possible, keep the definitions of each event type minimal, using functions (defined outside of the block) for the details of what is happening for each event.</p>

<pre><code class="r">## sample event type definitions from the default `randomLandscapes` module
doEvent.randomLandscapes &lt;- function(sim, eventTime, eventType, debug=FALSE) {
  if (eventType==&quot;init&quot;) {
    # do stuff for this event
    sim &lt;- randomLandscapesInit(sim)

    # schedule the next events
    sim &lt;- scheduleEvent(sim, params(sim)$randomLandscapes$.plotInitialTime,
                         &quot;randomLandscapes&quot;, &quot;plot&quot;)
    sim &lt;- scheduleEvent(sim, params(sim)$randomLandscapes$.saveInitialTime,
                         &quot;randomLandscapes&quot;, &quot;save&quot;)

  } else if (eventType==&quot;plot&quot;) {
    # do stuff for this event
    Plot(sim[[globals(sim)$stackName]])

    # schedule the next event
    sim &lt;- scheduleEvent(sim, time(sim) +
                           params(sim)$randomLandscapes$.plotInterval,
                         &quot;randomLandscapes&quot;, &quot;plot&quot;)
  } else if (eventType==&quot;save&quot;) {
    # do stuff for this event
    saveFiles(sim)

    # schedule the next event
    sim &lt;- scheduleEvent(sim, time(sim) +
                           params(sim)$randomLandscapes$.saveInterval,
                         &quot;randomLandscapes&quot;, &quot;save&quot;)

  } else {
    warning(paste(&quot;Undefined event type: \&#39;&quot;,
                  events(sim)[1, &quot;eventType&quot;, with=FALSE],
                  &quot;\&#39; in module \&#39;&quot;,
                  events(sim)[1, &quot;moduleName&quot;, with=FALSE],
                  &quot;\&#39;&quot;, sep=&quot;&quot;))
  }
  return(invisible(sim))
}
</code></pre>

<h3>Event functions</h3>

<p>Event functions should be defined below the <code>doEvent.moduleName</code> code block and follow the naming convention <code>modulenameEventtype()</code>.
Keep these function definitions as short and clean as possible (you can further modularize your functions by calling additional subroutines).</p>

<p>Functions should get and return objects in the simulation environment (<code>envir</code>), rather than pass them as function arguments.
This mostly allows for function definitions to be simpler, <em>i.e.</em>, they just take the one <code>sim</code> argument if parameters are passed within the <code>simInit</code> call.
Accessing objects in the <code>envir</code> is similar to accessing items in a list, <em>i.e.</em>, <code>sim[[&quot;object&quot;]]</code> or <code>sim$object</code> can be used, in addition to <code>get(&quot;object&quot;, envir=envir(sim))</code>. Likewise, simulation functions (<em>i.e.</em>, those defined in modules) are also accessed using the <code>$</code> accessor (<em>e.g.</em>, <code>sim$myFunction()</code>).</p>

<p>Note that every module requires an <code>&quot;init&quot;</code> event type, which defines the initialization of the module; however, this <code>init</code> event need not do a whole lot (<em>i.e.</em>, it can be a stub).
As such, the <code>modulenameInit()</code> function is required for initiliazation.
Modules may also include <code>&quot;save&quot;</code> and <code>&quot;plot&quot;</code> events, though these are optional.</p>

<pre><code class="r">## sample event functions from the default `randomLandscapes` module
require(raster)
randomLandscapesInit &lt;- function(sim) {
  if (is.null(params(sim)$randomLandscapes$inRAM)) {
    inMemory &lt;- FALSE
  } else {
    inMemory &lt;- params(sim)$randomLandscapes$inRAM
  }
  # Give dimensions of dummy raster
  nx &lt;- params(sim)$randomLandscapes$nx
  ny &lt;- params(sim)$randomLandscapes$ny
  r &lt;- raster(nrows=ny, ncols=nx, xmn=-nx/2, xmx=nx/2, ymn=-ny/2, ymx=ny/2)
  speedup &lt;- max(1, nx/5e2)
  # Make dummy maps for testing of models
  DEM &lt;- gaussMap(template, scale=300, var=0.03, speedup=speedup, 
                  inMemory=inMemory)
  DEM[] &lt;- round(getValues(DEM),1)*1000
  forestAge &lt;- gaussMap(template, scale=10, var=0.1, speedup=speedup, 
                        inMemory=inMemory)
  forestAge[] &lt;- round(getValues(forestAge),1)*20
  percentPine &lt;- gaussMap(template, scale=50, var=1, speedup=speedup, 
                          inMemory=inMemory)
  percentPine[] &lt;- round(getValues(percentPine), 1)

  # Scale them as needed
  forestAge &lt;- forestAge/maxValue(forestAge)*100
  percentPine &lt;- percentPine/maxValue(percentPine)*100

  # Make layers that are derived from other layers
  habitatQuality &lt;- (DEM+10 + (forestAge+2.5)*10)/100
  habitatQuality &lt;- habitatQuality/maxValue(habitatQuality)

  # Stack them into a single stack and assign to sim envir
  mapStack &lt;- stack(DEM, forestAge, habitatQuality, percentPine)
  names(mapStack) &lt;- c(&quot;DEM&quot;, &quot;forestAge&quot;, &quot;habitatQuality&quot;, &quot;percentPine&quot;)
  setColors(mapStack) &lt;- list(DEM=grDevices::terrain.colors(100),
                              forestAge=brewer.pal(9,&quot;BuGn&quot;),
                              habitatQuality=brewer.pal(8,&quot;Spectral&quot;),
                              percentPine=brewer.pal(9,&quot;Greens&quot;))
  sim[[globals(sim)$stackName]] &lt;- mapStack
  return(invisible(sim))
}
</code></pre>

<h3>Event diagram</h3>

<p>To better understand how events are scheduled within a simulation, a visual representation called an <code>eventDiagram</code> illustrates the sequences of events within a simulation.</p>

<p>Simulation time is presented on the x-axis, starting at date <code>startDate</code>.
Each module appears in a color-coded row, within which each event for that module is displayed corresponding to the sequence of events for that module.
Note that only the start time of the event is meaningful is these figures: the width of the bar associated with a particular module&#39;s event corresponds to the module&#39;s timestep unit, not the event&#39;s &ldquo;duration&rdquo;.</p>

<pre><code>## png 
##   2
</code></pre>

<pre><code class="r">mySim &lt;- spades(mySim)                   # runs the simulation
eventDiagram(mySim, &quot;0000-06-01&quot;, n=200) # overview of the events in the simulation
</code></pre>

<p>&lt;!&ndash;html_preserve&ndash;&gt;<div id="htmlwidget-7198" style="width:1000px;height:1586px;" class="DiagrammeR"></div>
<script type="application/json" data-for="htmlwidget-7198">{&quot;x&quot;:{&quot;diagram&quot;:&quot;gantt\ndateFormat  YYYY-MM-DD\ntitle SpaDES event diagram\nsection  checkpoint \n init:done,checkpoint1,0000-06-01,0000-06-05\nsection  save \n init:done,save1,0000-06-01,0000-06-05\nsection  load \n init:done,load1,0000-06-01,0000-06-05\nsection  randomLandscapes \n init:done,randomLandscapes1,0000-06-01,0000-06-05\nplot:crit,randomLandscapes2,0000-06-01,0000-06-05\nsection  caribouMovement \n init:done,caribouMovement1,0000-06-01,0000-06-05\nmove:active,caribouMovement2,0000-07-01,0000-07-05\nplot.init:active,caribouMovement3,0000-07-01,0000-07-06\nmove:active,caribouMovement4,0000-07-31,0000-08-05\nplot:crit,caribouMovement5,0000-08-01,0000-08-05\nmove:active,caribouMovement6,0000-08-31,0000-09-04\nplot:crit,caribouMovement7,0000-08-31,0000-09-05\nmove:active,caribouMovement8,0000-09-30,0000-10-05\nplot:crit,caribouMovement9,0000-10-01,0000-10-05\nmove:active,caribouMovement10,0000-10-31,0000-11-04\nplot:crit,caribouMovement11,0000-10-31,0000-11-04\nmove:active,caribouMovement12,0000-11-30,0000-12-05\nplot:crit,caribouMovement13,0000-11-30,0000-12-05\nmove:active,caribouMovement14,0000-12-31,0001-01-04\nplot:crit,caribouMovement15,0000-12-31,0001-01-04\nmove:active,caribouMovement16,0001-01-30,0001-02-04\nplot:crit,caribouMovement17,0001-01-30,0001-02-04\nmove:active,caribouMovement18,0001-03-01,0001-03-06\nplot:crit,caribouMovement19,0001-03-02,0001-03-06\nmove:active,caribouMovement20,0001-04-01,0001-04-05\nplot:crit,caribouMovement21,0001-04-01,0001-04-06\nmove:active,caribouMovement22,0001-05-01,0001-05-06\nplot:crit,caribouMovement23,0001-05-02,0001-05-06\nmove:active,caribouMovement24,0001-06-01,0001-06-05\nplot:crit,caribouMovement25,0001-06-01,0001-06-06\nmove:active,caribouMovement26,0001-07-01,0001-07-06\nplot:crit,caribouMovement27,0001-07-01,0001-07-06\nmove:active,caribouMovement28,0001-08-01,0001-08-05\nplot:crit,caribouMovement29,0001-08-01,0001-08-05\nmove:active,caribouMovement30,0001-08-31,0001-09-05\nplot:crit,caribouMovement31,0001-08-31,0001-09-05\nmove:active,caribouMovement32,0001-10-01,0001-10-05\nplot:crit,caribouMovement33,0001-10-01,0001-10-05\nmove:active,caribouMovement34,0001-10-31,0001-11-04\nplot:crit,caribouMovement35,0001-10-31,0001-11-05\nmove:active,caribouMovement36,0001-11-30,0001-12-05\nplot:crit,caribouMovement37,0001-12-01,0001-12-05\nmove:active,caribouMovement38,0001-12-31,0002-01-04\nplot:crit,caribouMovement39,0001-12-31,0002-01-05\nmove:active,caribouMovement40,0002-01-30,0002-02-04\nplot:crit,caribouMovement41,0002-01-31,0002-02-04\nmove:active,caribouMovement42,0002-03-02,0002-03-06\nplot:crit,caribouMovement43,0002-03-02,0002-03-06\nmove:active,caribouMovement44,0002-04-01,0002-04-06\nplot:crit,caribouMovement45,0002-04-01,0002-04-06\nmove:active,caribouMovement46,0002-05-02,0002-05-06\nplot:crit,caribouMovement47,0002-05-02,0002-05-06\nmove:active,caribouMovement48,0002-06-01,0002-06-06\nsection  fireSpread \n init:done,fireSpread1,0000-06-01,0000-06-05\nburn:active,fireSpread2,0000-06-01,0000-06-05\nstats:active,fireSpread3,0000-06-01,0000-06-05\nplot.init:active,fireSpread4,0000-07-07,0000-07-12\nburn:active,fireSpread5,0001-06-01,0001-06-05\nstats:active,fireSpread6,0001-06-01,0001-06-05\nburn:active,fireSpread7,0002-06-01,0002-06-06\nstats:active,fireSpread8,0002-06-01,0002-06-06\n&quot;},&quot;evals&quot;:[]}</script>&lt;!&ndash;/html_preserve&ndash;&gt;</p>

<h2>Module documentation (<code>moduleName.Rmd</code>)</h2>

<p>Module documentation should be written so that others can use your module.
As such, this documentation should include a high-level overview of the module as well as low-level, detailed descriptions of its usage.</p>

<p>We strongly recommend using RMarkdown (<code>.Rmd</code>) for this documentation, as it is easily human-readible while also being machine-readible and easily converted to a wide variety of file formats including <code>PDF</code>, <code>HTML</code>, and <code>DOCX</code>.
Another benefit of using a text-based file format is to facilitate transparent document versioning and history using version control systems like <code>git</code>.
For help writing in RMarkdown, see <a href="http://rmarkdown.rstudio.com/">http://rmarkdown.rstudio.com/</a>.</p>

<h2>Citation, License, and Readme files</h2>

<ul>
<li><p><code>citation.bib</code> provides a <code>BibTeX</code> formatted citation with which the module can be referenced.
Most citation management software can read and output <code>.bib</code> format.</p></li>
<li><p><code>LICENSE.txt</code> describes how your module can be redistributed and used by others.
For help selecting a license, see <a href="http://choosealicense.com">choosealicense.com</a>.</p></li>
<li><p><code>README.txt</code> is used to briefly document module metadata and version change information.</p></li>
</ul>

<h2>Versioned zip archives (<code>moduleName_x.y.z.zip</code>)</h2>

<p>Use <a href="http://semver.org">semantic versioning</a>, such that a version number <code>x.y.z</code> corresponds to:</p>

<ul>
<li><code>x</code> is the <strong>major</strong> version (incremented when you make incompatible API changes)</li>
<li><code>y</code> is the <strong>minor</strong> version (incremeted when you add functionality in a backwards-compatible manner)</li>
<li><code>z</code> is the <strong>patch</strong> version (incremented when you make backwards-compatible bug fixes)</li>
</ul>

<p>\newpage</p>

<h1>Passing data between modules</h1>

<p>Modularity in <code>SpaDES</code> simulations is maintained by ensuring modules interact indirectly with one another by reading in and modifying objects in the simluation environment.</p>

<h2>Data types</h2>

<p>As you build your modules for your simulation, you can use any of <code>R</code>&#39;s data types to store your objects and data.
In particular, matrices (including vectors) and lists work well for this purpose because, as of <code>R</code> version <code>3.1.0</code>, they are more efficient, reducing your model&#39;s memory footprint and speeding up your code&#39;s execution.
Other useful datatypes include <code>Raster*</code> and <code>SpatialPoints*</code> objects (see examples below).</p>

<h2>Global objects and the simluation environment</h2>

<p><code>R</code> passes copies of objects to functions (instead of using pass-by-reference), so the typical <code>R</code> function never acts directly on the global copy of the variable.
Within a function, all operations are generally performed on a local copy of the object, which is then either discarded or returned back to the parent environment upon when the function completes.
This object-copying behaviour has given <code>R</code> a reputation of being slow in comparison to languages like <code>C</code> and <code>FORTRAN</code>.
However, recent improvements to <code>R</code> have made it more memory efficient and faster to execute, in part by minimizing the number of object copies made and lazy loading.</p>

<p>One way <code>SpaDES</code> reduces object copying is by storing and modifying objects in a simulation environment, because environments in R have <a href="http://adv-r.had.co.nz/Environments.html">reference semantics</a>.
Instead of storing simulation data in the global environment, each <code>SpaDES</code> simulation uses a unique environment wherein simulation data are referenced.</p>

<h2>Module object dependencies</h2>

<p>As noted above, modules should not depend on one another for event scheduling.
However, it is often useful to develop collections of modules that interact indirectly and are dependent on shared data objects.
Modules can be designed to rely on outputs (data objects) from other modules.
When objects are shared between modules, it is important to state these dependencies explicitly.
To check whether objects upon which a model depends exist, a call to <code>checkObject</code> is made during module initilization.</p>

<p>Note that modules need not be inter-dependent on one another: module B may depend on module A (for example to initialize a data object), without module A depending on module B.</p>

<p>To view the dependencies for a simulation:</p>

<pre><code class="r">require(SpaDES)

times &lt;- list(start=0.0, end=20)
parameters &lt;- list(.globals=list(stackName=&quot;landscape&quot;, burnStats=&quot;nPixelsBurned&quot;))
modules &lt;- list(&quot;randomLandscapes&quot;, &quot;fireSpread&quot;, &quot;caribouMovement&quot;)
paths &lt;- list(modulePath=system.file(&quot;sampleModules&quot;, package=&quot;SpaDES&quot;))

mySim &lt;- simInit(times=times, params=parameters, modules=modules, paths=paths)

## examine simulation module (object) dependencies
depsEdgeList(mySim, FALSE)  # all object dependency relationships
</code></pre>

<pre><code>##                from              to       objName    objClass
## 1:  caribouMovement caribouMovement     landscape RasterStack
## 2:  caribouMovement      fireSpread     landscape RasterStack
## 3:       fireSpread caribouMovement     landscape RasterStack
## 4:       fireSpread      fireSpread     landscape RasterStack
## 5:       fireSpread      fireSpread nPixelsBurned     numeric
## 6: randomLandscapes caribouMovement     landscape RasterStack
## 7: randomLandscapes      fireSpread     landscape RasterStack
</code></pre>

<pre><code class="r">moduleDiagram(mySim)        # simplified visual representation of modules
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk depsGraph"/> </p>

<pre><code class="r">objectDiagram(mySim)        # detailed visual representation of objects
</code></pre>

<p>&lt;!&ndash;html_preserve&ndash;&gt;<div id="htmlwidget-9111" style="width:504px;height:504px;" class="DiagrammeR"></div>
<script type="application/json" data-for="htmlwidget-9111">{&quot;x&quot;:{&quot;diagram&quot;:&quot;sequenceDiagram\ncaribouMovement -&gt;&gt; caribouMovement : landscape\ncaribouMovement -&gt;&gt; fireSpread : landscape\nfireSpread -&gt;&gt; caribouMovement : landscape\nfireSpread -&gt;&gt; fireSpread : landscape\nfireSpread -&gt;&gt; fireSpread : nPixelsBurned\nrandomLandscapes -&gt;&gt; caribouMovement : landscape\nrandomLandscapes -&gt;&gt; fireSpread : landscape\n&quot;},&quot;evals&quot;:[]}</script>&lt;!&ndash;/html_preserve&ndash;&gt;</p>

<p>The output of the <code>depsEdgeList</code> is an edgelist describing the relationships between each module.
In the example above, line 2 of the output indicates that the <code>fireSpread</code> module relies on an object <code>landscape</code> provided by the <code>caribouMovement</code> module.
This edgelist is used inside the <code>depsGraph</code> function to produce a dependency graph (network), where each module corresponds to a vertex (node), and object dependencies are denoted by the arrows.
When plotting the dependency graph, it&#39;s often useful to use the <code>plot=TRUE</code> argument to simplify the network by showing no more than one object dependency between modules.</p>

<p>\newpage</p>

<h1>Core modules</h1>

<p>There are a number of built-in modules that provide useful functionality such as plotting and saving.
These modules have their names prefaced with a dot (<code>.</code>).
Parameter values for core modules can be accessed by using their accessor methods; however, these are simply entries in a nested list exactly like the parameters passed to user modules, and can be accessed directly as such.</p>

<p>These core modules are summarized in the following table and described further below.</p>

<table><thead>
<tr>
<th><strong>Module Name</strong></th>
<th><strong>Parameterization</strong></th>
<th><strong>Accessor Methods</strong></th>
</tr>
</thead><tbody>
<tr>
<td><strong><code>.checkpoint</code></strong></td>
<td><code>file</code>: character.</td>
<td><code>checkpointFile()</code></td>
</tr>
<tr>
<td>&nbsp;</td>
<td><code>interval</code>: numeric (or <code>NA</code>).</td>
<td><code>checkpointInterval()</code></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><strong><code>.plot</code></strong></td>
<td><code>.plotInitialTime</code>: numeric (or <code>NA</code>)</td>
<td>as list item in your module parameters.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td><code>.plotInterval</code>: numeric (or <code>NA</code>)</td>
<td>as list item in your module parameters.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><strong><code>.progress</code></strong></td>
<td><code>type</code>: one of <code>&quot;text&quot;</code>, <code>&quot;graphical&quot;</code>,</td>
<td><code>progressType()</code></td>
</tr>
<tr>
<td>&nbsp;</td>
<td><code>&quot;shiny&quot;</code>, or <code>NA</code>.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>&nbsp;</td>
<td><code>interval</code>: numeric (or <code>NA</code>).</td>
<td><code>progressInterval()</code></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><strong><code>.load</code></strong></td>
<td><code>inputs</code>: data.frame</td>
<td><code>inputs()</code> or passed as <code>inputs</code> argument to <code>simList</code></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><strong><code>.save</code></strong></td>
<td><code>ouputs</code>: data.frame</td>
<td><code>outputs()</code> or passed as <code>outputs</code> argument to <code>simList</code></td>
</tr>
<tr>
<td>&nbsp;</td>
<td><code>.saveInitialTime</code>: numeric (or <code>NA</code>)</td>
<td>as list item in your module parameters.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td><code>.saveInterval</code>: numeric (or <code>NA</code>)</td>
<td>as list item in your module parameters.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td><code>.saveObjects</code>: character.</td>
<td>as list item in your module parameters.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td><code>.savePath</code>: character.</td>
<td>as list item in your module parameters.</td>
</tr>
</tbody></table>

<h2><code>.checkpoint</code> module</h2>

<p>Schedule automatic simulation checkpointing to allow you to resume a previously saved simulation.
All objects in the global environment including the state of the random number generator are saved and can be reloaded.
Checkpoint frequency and filename can be passed as parameters to the simulation object as illustrated below.
By befault, checkpointing is not used unless the <code>interval</code> parameter is provided; the simulation checkpoint file (if one exists) is loaded if the <code>file</code> parameter is specified.</p>

<pre><code class="r"># initialize a new simulation, setting the checkpoint interval and filename.
times &lt;- list(start=0, end=30)
parameters &lt;- list(.globals=list(stackName=&quot;landscape&quot;),
                   .checkpoint=list(interval=10, file=&quot;chkpnt.RData&quot;))
modules &lt;- list(&quot;randomLandscapes&quot;, &quot;caribouMovement&quot;)
paths &lt;- list(modulePath=system.file(&quot;sampleModules&quot;, package=&quot;SpaDES&quot;))

mySim &lt;- simInit(times=times, params=parameters, modules=modules, paths=paths)

# retrieve the checkpoint params from the simulation object
checkpointFile(mySim)
</code></pre>

<pre><code>## [1] &quot;chkpnt.RData&quot;
</code></pre>

<pre><code class="r">checkpointInterval(mySim)
</code></pre>

<pre><code>## [1] 10
</code></pre>

<h2><code>.progress</code> module</h2>

<p>Schedule updates to the simulation progress bar.</p>

<pre><code class="r"># initialize a new simulation, setting the progress parameters
mySim &lt;- simInit(times=list(start=0.0, end=100.0),
                 params=list(.globals=list(stackName=&quot;landscape&quot;),
                             .progress=list(type=&quot;text&quot;, interval=10)),
                 modules=list(&quot;randomLandscapes&quot;),
                 paths=list(modulePath=system.file(&quot;sampleModules&quot;, package=&quot;SpaDES&quot;)))

# retrieve the checkpoint params from the simulation object
progressType(mySim)
</code></pre>

<pre><code>## [1] &quot;text&quot;
</code></pre>

<pre><code class="r">progressInterval(mySim)
</code></pre>

<pre><code>## [1] 10
</code></pre>

<h2><code>.load</code> and <code>.save</code> modules</h2>

<p>Schedule object save and file load events by passing parameters to the save and load parameters for each module. 
Saving objects to file can be done at the module level or at the model level.
At the module level, each module can be provided with appropriate arguments as parameters. 
In all cases, these must be events that are scheduled in the modules that do the saving or loading, and then the parameters necessary to make those events happen must be specified. 
Modules are not required to have the following parameters set, but when using <code>newModule()</code> to create the module, these will be events that are made, but not scheduled:</p>

<table><thead>
<tr>
<th><strong>Argument</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td><strong><code>.saveInitialTime</code></strong></td>
<td>Numeric specifying the time at which the first save is scheduled (between <code>start(sim)</code> and <code>end(sim)</code>).</td>
</tr>
<tr>
<td><strong><code>.saveInterval</code></strong></td>
<td>Numeric specifying the interval at which objects will be saved.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>Used to schedule save events.</td>
</tr>
<tr>
<td><strong><code>.saveObjects</code></strong></td>
<td>Character vector naming the objects to be saved.</td>
</tr>
</tbody></table>

<h3><code>inputs</code> argument to simInit</h3>

<p>Alternatively, objects can be read in during the <code>simInit</code> function call by passing a data.frame to the <code>input</code> argument. 
For <code>inputs()</code>, the <code>data.frame</code> must consist of, minimally, a column named <code>file</code> listing the absolute or relative filepaths of the files to be loaded.
Additional columns can also be provided:</p>

<table><thead>
<tr>
<th><strong>Column Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td><strong><code>file</code></strong></td>
<td>Character string indicating the absolute or relative file path to individual file to load.</td>
</tr>
<tr>
<td><strong><code>objectName</code></strong></td>
<td>Character string indicating the name of the object once the file is loaded.</td>
</tr>
<tr>
<td><strong><code>fun</code></strong></td>
<td>Character string indicating the function to be used to load the file. Can use <code>package::fun</code> notation.</td>
</tr>
<tr>
<td><strong><code>package</code></strong></td>
<td>Character string indicating the package to load the <code>fun</code> from. Not required if <code>fun</code> uses <code>package::fun</code> notation</td>
</tr>
<tr>
<td><strong><code>intervals</code></strong></td>
<td>Numeric indicating the interval between repeated loading of the same file.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>This should be <code>NA</code> or the column absent if the file is only loaded once.</td>
</tr>
<tr>
<td><strong><code>loadTime</code></strong></td>
<td>Numeric indicating when the file should be loaded. Defaults to <code>simTime = 0</code>, but this</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>can be any time. The loading will be scheduled to occur at the <code>loadTime</code>.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>If the same file is to be loaded many times, but not at a regular interval, then there</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>should be separate line, with a unique <code>loadTime</code> for each.</td>
</tr>
<tr>
<td><strong><code>args</code></strong></td>
<td>List of lists of named arguments; one list for each loading function.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>For example, if <code>raster</code> is a loading function, <code>args = list(native = TRUE)</code>.</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>If there is only one list, then it is assumed to apply to all load attempts and will be</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>repeated for each load function.</td>
</tr>
</tbody></table>

<h3><code>outputs</code> argument to simInit</h3>

<p>Objects to be saved can be specified using the <code>output</code> argument, by passing a data.frame analogous to the <code>.load</code> module. 
This <code>data.frame</code> is passed via the <code>outputs</code> argument in the <code>simInit</code> call or via a <code>outputs(mySim) &lt;- data.frame()</code>.</p>

<p>Saving files can be done &ldquo;at the model level&rdquo; by passing a simulation parameter called <code>outputs</code> which can be a <code>data.frame</code> and consists minimally of a column named <code>objectNames</code>.
This will identify which objects should be saved. 
Additional columns can also be provided:</p>

<table><thead>
<tr>
<th><strong>Column Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td><strong><code>objectName</code></strong></td>
<td>Character string indicating the name of the object once the file is loaded.</td>
</tr>
<tr>
<td><strong><code>file</code></strong></td>
<td>Character string indicating the base name to use to name the saved file.</td>
</tr>
<tr>
<td><strong><code>fun</code></strong></td>
<td>Character string indicating the function to be used to save the file.</td>
</tr>
<tr>
<td><strong><code>package</code></strong></td>
<td>Character string indicating the package to find the previous <code>fun</code> in.</td>
</tr>
<tr>
<td><strong><code>saveTime</code></strong></td>
<td>Numeric indicating when the file should be saved. Defaults to <code>end(simList)</code>, but this can be any time. For multiple saves of the same object, use unique lines, e.g., via <code>data.table(expand.grid(objectName=c(&quot;caribou&quot;, &quot;veg&quot;), saveTime=1:10))</code></td>
</tr>
</tbody></table>

<p>SpaDES will add a 6th column, <code>saved</code>, a logical, which will become TRUE when (immediately following) the successful save occurs.<br/>
Therefore, a call to <code>outputs(mySim)</code> will indicate which objects have been saved.</p>

<p>There is partial string matching of these names, so 
If the <code>fun</code> requires arguments to be passed to it, use <code>outputArgs()</code>, and it must be the same length as the <code>outputs()</code> <code>data.frame</code>.</p>

<pre><code class="r"># initialize a new simulation, setting the load and save parameters
require(data.table)

outputDir &lt;- file.path(tempdir(), &quot;simOutputs&quot;)
mySim &lt;- simInit(times=list(start=0.0, end=10),
                 params=list(
                   .globals=list(stackName=&quot;landscape&quot;),
                   randomLandscapes=list(
                     .saveInitialTime=0, .saveInterval=10, .saveObjects=c(&quot;landscape&quot;),
                     .savePath=file.path(outputDir, &quot;randomLandscapes&quot;))
                   ),
                 modules=list(&quot;randomLandscapes&quot;),
                 paths=list(modulePath=system.file(&quot;sampleModules&quot;, package=&quot;SpaDES&quot;),
                            outputPath=outputDir),
                 #inputs=data.table(file=filelist),
                 outputs=data.table(objectName=&quot;landscape&quot;)
)

# retrieve the load and save params from the simulation object
inputs(mySim)    # shows all files and objects that are &quot;inputs&quot;
</code></pre>

<pre><code>## [1] file       fun        package    objectName loadTime   loaded    
## &lt;0 rows&gt; (or 0-length row.names)
</code></pre>

<pre><code class="r">outputs(mySim)   # shows all files and objects that are &quot;outputs&quot;
</code></pre>

<pre><code>##   objectName                                               file     fun
## 1  landscape C:/Temp/RtmpEx84Z3/simOutputs/landscape_year10.rds saveRDS
##   package saveTime saved
## 1    base       10    NA
</code></pre>

<pre><code class="r">params(mySim)$randomLandscapes$.saveInitialTime
</code></pre>

<pre><code>## [1] 0
</code></pre>

<pre><code class="r">params(mySim)$randomLandscapes$.saveInterval
</code></pre>

<pre><code>## [1] 10
</code></pre>

<pre><code class="r">params(mySim)$randomLandscapes$.saveObjects
</code></pre>

<pre><code>## [1] &quot;landscape&quot;
</code></pre>

<pre><code class="r">params(mySim)$randomLandscapes$.savePath
</code></pre>

<pre><code>## [1] &quot;C:\\Temp\\RtmpEx84Z3/simOutputs/randomLandscapes&quot;
</code></pre>

<pre><code class="r">ftmp &lt;- file.path(tempdir(), &quot;spades_vignetteOutputs&quot;)
pdf(ftmp)
clearPlot()
mySim2 &lt;- spades(mySim)
</code></pre>

<pre><code>## Warning in saveFiles(sim): landscape is not an object in the simList.
## Cannot save.
</code></pre>

<pre><code class="r"># More sophisticated, passing arguments to outputs()
outputs(mySim) &lt;- data.table(
  objectName=&quot;landscape&quot;, fun=&quot;writeRaster&quot;, package=&quot;raster&quot;,
  saveTime=c(3,6), args=lapply(c(3,6), function(x) {
    list(dataType=&quot;FLT4S&quot;, format=&quot;raster&quot;, overwrite=TRUE)
  }))
mySim2 &lt;- spades(mySim)
</code></pre>

<pre><code>## Warning in saveFiles(sim): landscape is not an object in the simList.
## Cannot save.
</code></pre>

<pre><code>## Warning in saveFiles(sim): landscape is not an object in the simList.
## Cannot save.
</code></pre>

<pre><code class="r">dev.off()
</code></pre>

<pre><code>## png 
##   2
</code></pre>

<pre><code class="r">unlink(ftmp)
</code></pre>

<p>Saving within a module &ndash; scheduling save events.</p>

<pre><code class="r">### WITHIN A MODULE:

# schedule a recurring save event
nextSave &lt;- time(mySim) + params(mySim)$randomLandscapes$.saveInterval
sim &lt;- scheduleEvent(mySim, nextSave, &quot;randomLandscapes&quot;, &quot;save&quot;)
</code></pre>

<h2>Plotting</h2>

<p>Plotting events can be scheduled similarly to save events, by passing module-specific parameters indicating when to schedule the first plot event and how often to rescheduling recurring plot events. By default, when a module is created with a <code>newModule()</code> call, plotting will be scheduled using <code>.plotIntitialTime</code>. The default is NA, i.e., no plotting.</p>

<ul>
<li><code>.plotInitialTime</code>: The time at which the first plot is scheduled.</li>
<li><code>.plotInterval</code>: The interval at which objects will be plotted. Used to schedule plot events.</li>
</ul>

<pre><code class="r"># initialize a new simulation, setting the load and save parameters
mySim &lt;- simInit(times=list(start=0.0, end=100),
                 params=list(
                   .globals=list(stackName=&quot;landscape&quot;),
                   randomLandscapes=list(.plotInitialTime=0, .plotInterval=1)
                 ),
                 modules=list(&quot;randomLandscapes&quot;),
                 paths=list(modulePath=system.file(&quot;sampleModules&quot;, package=&quot;SpaDES&quot;))
)

# retrieve the plotting params from the simulation object
params(mySim)$randomLandscapes$.plotInitialTime
params(mySim)$randomLandscapes$.plotInterval
</code></pre>

<pre><code class="r">### WITHIN A MODULE:

# schedule a recurring plot event
nextPlot &lt;- time(mySim) + params(mySim)$randomLandscapes$.plotInterval
mySim &lt;- scheduleEvent(mySim, nextPlot, &quot;randomLandscapes&quot;, &quot;save&quot;)
</code></pre>

<p>\newpage</p>

<h1>Using existing <code>SpaDES</code> modules</h1>

<p>One of the primary motivations of developing the <code>SpaDES</code> package is to facilitate module reuse.
We provide a few modules with this package as samples for demos and the vignettes, which can be used as a starting point for your own module development.
We also maintain a publically accessible repository of <code>SpaDES</code> modules (details below).</p>

<p>Before using other modules, it is up to the modeler (you!) to understand the technical and scientific limitations of these modules.
Although <code>SpaDES</code> provides some built-in functionality to ensure different modules will work together, and warn the user if certain module combinations are invalid, when deciding upon which modules to use, be sure to also:</p>

<ol>
<li>Ensure you are using a suitable <code>R</code> version;</li>
<li>Check package dependencies and ensure you have the necesary packages installed on your system;</li>
<li>Check module object dependencies (<code>simInit</code> does this);</li>
<li>Check module compatibility (<em>e.g.</em>, spatial extent, timeframe, etc.) (<code>simInit</code> only does a basic version of this).</li>
</ol>

<p>See the <code>SpaDES</code> wiki (<a href="https://github.com/PredictiveEcology/SpaDES/wiki">https://github.com/PredictiveEcology/SpaDES/wiki</a>) for more detailed information on getting started.</p>

<h2>Included sample modules</h2>

<p>Use <code>system.file(&quot;sampleModules&quot;, package=&quot;SpaDES&quot;)</code> to get the path to the <code>sampleModules</code> directory.
To view the contents of a module, use the <code>openModules</code> function.
Note that you shouldn&#39;t edit the sample modules directly, but save them as a copy in another location.</p>

<pre><code class="r">openModules(system.file(&quot;sampleModules&quot;, package=&quot;SpaDES&quot;), &quot;moduleName&quot;)
</code></pre>

<ol>
<li><p><code>randomLandscapes</code>:
Generate RasterStack of random maps representative of a forest landscape (<code>DEM</code>, <code>forestAge</code>, <code>habitatQuality</code>, <code>percentPine</code>).
Requires a global simulation parameter <code>stackName</code> be set.</p></li>
<li><p><code>fireSpread</code>:
Simulate fire ignition and spread on a landscape, where spread probability varies according to percent pine.
Fire size statistics are collected immediately after each burn event.
Requires a global simulation parameter <code>stackName</code> be set.</p></li>
<li><p><code>caribouMovement</code>:
Agent based model of caribou movement via correlated random walk.
Requires a RasterStack object whose name is specified by <code>globals(sim)$stackName</code>, containing a RasterLayer named <code>habitatQuality</code>.</p></li>
</ol>

<h2><code>SpaDES</code> module repository</h2>

<p><strong>Website:</strong> <a href="https://github.com/PredictiveEcology/SpaDES-modules">https://github.com/PredictiveEcology/SpaDES-modules</a></p>

<p>Modules from this (or another suitable GitHub repository) can be downloaded using:</p>

<pre><code class="r">downloadModule(&quot;moduleName&quot;, &quot;path/to/my/modules/directory&quot;)
</code></pre>

<p>\newpage</p>

<h1>Creating new modules</h1>

<h2>Module design considerations</h2>

<p>As noted above, modules should function as independently as possible so that they retain their modularity.
While it may be useful for modules to exhibit indirect dependence on each other via shared data objects (such as maps), modules should not depend directly on each other via event scheduling.</p>

<h2>Using the module template</h2>

<p>Code for new modules can be developed quickly using the template generator function <code>newModule</code> which accepts as arguments the name of the new module, a directory path in which to create the new module, and a logical indicating whether to open the newly created module code file for editing.</p>

<pre><code class="r"># create a new module called &quot;randomLandscape&quot; in the &quot;custom-modules&quot; subdirectory
# and open the resulting file immediately for editing.
newModule(name=&quot;randomLandscapes&quot;, path=&quot;custom-modules&quot;, open=TRUE)
</code></pre>

<p>The newly created file can now be modified in the identified sections and customized to your module.
However, it is very important that you do not edit portions of the file outside of the designated sections or your module may fail to work properly within a simulation.</p>

<h2>Module groups</h2>

<p>A &#39;module group&#39; is simply a convenient way of specifying multiple modules.
Module groups are specified by naming child modules in the <code>defineModule</code> block of the metadata.
For example, the <code>SpaDES_sampleModules</code> module group lists the following modules as &ldquo;children&rdquo;:</p>

<ul>
<li><code>caribouMovement</code></li>
<li><code>fireSpread</code></li>
<li><code>randomLandscapes</code></li>
</ul>

<p>Module groups make loading multiple modules easier: only the name of the module group needs to be specified in the <code>simInit</code> call, which will then initialize the simulation with the child modules.</p>

<pre><code class="r">library(SpaDES)

outputDir &lt;- file.path(tempdir(), &quot;simOutputs&quot;)
times &lt;- list(start=0.0, end=20.0)
parameters &lt;- list(.globals=list(stackName=&quot;landscape&quot;, burnStats=&quot;nPixelsBurned&quot;),
                   .progress=list(NA),
                   randomLandscapes=list(nx=100L, ny=100L, inRAM=TRUE),
                   fireSpread=list(nFires=10L, spreadprob=0.225, its=1e6,
                                   persistprob=0, returnInterval=10, startTime=0,
                                  .plotInitialTime=0.1, .plotInterval=10),
                   caribouMovement=list(N=100L, moveInterval=1, torus=TRUE,
                                        .plotInitialTime=1.01, .plotInterval=1))
modules &lt;- list(&quot;SpaDES_sampleModules&quot;)
objects &lt;- list()
paths &lt;- list(modulePath=system.file(&quot;sampleModules&quot;, package=&quot;SpaDES&quot;),
              outputPath=outputDir)

mySim &lt;- simInit(times=times, params=parameters, modules=modules,
                 objects=objects, paths=paths)

modules(mySim) # note the child modules are initialized
</code></pre>

<p>Module groups can also be used to simplify the download of multiple modules (not yet implemented; <a href="https://github.com/PredictiveEcology/SpaDES/issues/208">issue #208</a>):</p>

<pre><code class="r">downloadModule(&quot;SpaDES_sampleModules&quot;) # not yet implemented
</code></pre>

<h2>Contributing modules</h2>

<p>After publication you may wish to make your module more easily accessible for others to use (in fact we encourage it).
We maintain a repository of <code>SpaDES</code> modules at the following site: <a href="https://github.com/PredictiveEcology/SpaDES-modules">https://github.com/PredictiveEcology/SpaDES-modules</a></p>

<h3>Minimum requirements</h3>

<p>All contributed modules should be well documented.
In addition to providing <em>complete</em> metadata within the module&#39;s <code>.R</code> file, the following components (see details above) should be included:</p>

<ol>
<li>Complete module documentation, such as an Rmarkdown (<code>.Rmd</code>) document that can be built as a <code>PDF</code>.</li>
<li>A <code>citation.bib</code> file containing a BibTeX-formatted citation for your module (or for the publication describing your module). This citation will be used by others when citing your module.</li>
<li>A <code>LICENSE</code> file describing how your module code may be used and modified.</li>
<li>A <code>README</code> file containing an overview of your module and updates that are included with each version.</li>
</ol>

<p>Note that <code>newModule()</code> produces skeleton templates of these files.
Additionally, <code>zipModule()</code> can be used to build the <code>.zip</code> file corresponding to a particular version of your module.</p>

<h3>Module submission</h3>

<p>To submit your module for inclusion in our GitHub repository, login to GitHub with your account and initiate a pull request to the repository.
See the <a href="https://help.github.com/articles/creating-a-pull-request/">GitHub help documentation</a> for more details.</p>

</body>

</html>
